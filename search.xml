<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MathJax Test]]></title>
    <url>%2F2017%2F07%2F14%2FMathJax-Test%2F</url>
    <content type="text"><![CDATA[Use MathJax to show math equation $$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\\nabla\cdot\vec{B} &amp;=&amp; 0 \\\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$ InstallMathJax allows you to include mathematics in your web pages, either using LaTeX, MathML, or AsciiMath notation, and the mathematics will be processed using JavaScript to produce HTML, SVG or MathML equations for viewing in any modern browser. to use MathJax in the blog, We need to install a plugin to auto-deploy the Mathjax:12npm install hexo-math --savehexo math install don’t add anything in _config.yml!!! Noteif there are some trouble in using MathJax, Modify the file：./node_modules/marked/lib/marked.js: step1replaceescape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,withescape: /^\\([`*\[\]()# +\-.!_&gt;])/, step2replaceem: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,withem:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, please ignore above if your MathJax work well UseUse LaTeX to write math equation,like: sup(^) and sub(_)$$ e^{i\pi}+1=0 $$ frac$$ \frac{1}{3} $$ sqrt$$ \sqrt[n]{x+y} $$ vector$$ \vec{a}\cdot\vec{b} = 0 $$ integrate$$ \int_0^1x^2{\rm d}x $$ limit$$ \lim_{n \rightarrow + \infty}\frac{1}{n(n+1)} $$ sum$$ \sum_{i=0}^n\frac{1}{i^2} $$ greek alphabet$$\alpha \quad \beta \quad \gamma \quad \delta \quad \epsilon \quad \theta \quad \lambda \quad\mu \quad \eta \\\nu \quad \xi \quad \pi \quad \rho \quad \sigma \quad \tau \quad \phi \quad \psi \quad \omega$$]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy Quickstart Tutorial]]></title>
    <url>%2F2017%2F05%2F22%2FNumpy-Quickstart-Tutorial%2F</url>
    <content type="text"><![CDATA[QuickStart For Numpy 1. The Basics1234import numpy as np# create am array and showa = np.arange(15).reshape(3,5)a array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 12# show every axis's length of an arraya.shape (3, 5) 12# show an array's dima.ndim 2 12# show data type of an arraya.dtype dtype(&apos;int64&apos;) 12# show itemsize of an arraya.size 15 12# show type of atype(a) numpy.ndarray 123# create another arrayb = np.array([6, 7, 8])b array([6, 7, 8]) 2. Array Creation2.1 create array by regular Python list or tuple1234import numpy as npa = np.array((2, 3, 4))a array([2, 3, 4]) 12b = np.array([5, 6, 7])b array([5, 6, 7]) 12c = np.array([[1, 2, 3], [4, 5, 6]])c array([[1, 2, 3], [4, 5, 6]]) 2.2 create array by functions123# zeros, default type is float64a = np.zeros((3,4))a.dtype dtype(&apos;float64&apos;) 123# onesb = np.ones((2, 3), dtype = np.int16)b array([[1, 1, 1], [1, 1, 1]], dtype=int16) 1234# empty, it create an array by random itemc = np.empty((2, 2))c array([[ 6.94428861e-310, 1.15911595e-316], [ 4.76862566e+180, 1.63041663e-322]]) 123# arange, give the begin, the step and the andnp.arange(10, 30, 5) array([10, 15, 20, 25]) 123# linspace, give the begin, the end and the number of elementsnp.linspace(0, 2, 9) array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 3. printing Arrays1234# 1d arraya = np.arange(6)print(a) [0 1 2 3 4 5] 1234# 2d arrayb = np.arange(12).reshape(4,3)print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] 123# too long arrayprint(np.arange(10000)) [ 0 1 2 ..., 9997 9998 9999] 1print(np.arange(10000).reshape(100, 100)) [[ 0 1 2 ..., 97 98 99] [ 100 101 102 ..., 197 198 199] [ 200 201 202 ..., 297 298 299] ..., [9700 9701 9702 ..., 9797 9798 9799] [9800 9801 9802 ..., 9897 9898 9899] [9900 9901 9902 ..., 9997 9998 9999]] 4. Basic Operations4.1 Arithmetic operations on arrays apply elementwise1234567# + - * /a = np.arange(4, dtype = np.float64)b = np.array([2, 3, 4, 5])print(a+b)print(a-b)print(a*b)print(a/b) [ 2. 4. 6. 8.] [-2. -2. -2. -2.] [ 0. 3. 8. 15.] [ 0. 0.33333333 0.5 0.6 ] 1234# othersprint(b**2)print(np.sin(a))print(a&lt;3) [ 4 9 16 25] [ 0. 0.84147098 0.90929743 0.14112001] [ True True True False] 4.2 matrix product123456A = np.array([[1, 2], [3, 4]])B = np.array([[4, 2], [3, 1]])# multi by elementprint(A*B)# matrix multiprint(A.dot(B)) [[4 4] [9 4]] [[10 4] [24 10]] 4.3 unary operations12345a = np.arange(1, 5)print(a)print(a.sum())print(a.max())print(a.min()) [1 2 3 4] 10 4 1 123456# for 2db = np.arange(1, 5).reshape(2, 2)print(b)print(b.sum())print(b.sum(axis = 0)) [[1 2] [3 4]] 10 [4 6] 5. Universal Functions123B = np.arange(3)print(np.exp(B))print(np.sqrt(B)) [ 1. 2.71828183 7.3890561 ] [ 0. 1. 1.41421356] See also: all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where 6. Indexing, Slicing and Iterating12a = np.arange(10)**3a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729]) 12print(a[2])print(a[2:5]) 8 [ 8 27 64] 123a[:6:2] = -1000print(a)print(a[::-1]) [-1000 1 -1000 27 -1000 125 216 343 512 729] [ 729 512 343 216 125 -1000 27 -1000 1 -1000] 1234567# create arrays from functiondef f(x, y): return 10*x+yb = np.fromfunction(f, (5, 4), dtype = int)print(b) [[ 0 1 2 3] [10 11 12 13] [20 21 22 23] [30 31 32 33] [40 41 42 43]] 1234print(b[2,3])print(b[0:5,1])print(b[:,1])print(b[-1]) 23 [ 1 11 21 31 41] [ 1 11 21 31 41] [40 41 42 43] 123456# flat is an iterator and flatten is a functionA = np.array([[1,2],[3,4]])print(A)print(A.flatten())for element in A.flat: print(element) [[1 2] [3 4]] [1 2 3 4] 1 2 3 4 7. Shape Manipulation7.1 Changing the shape of an array1234# create an arraya = np.floor(10*np.random.random((3,4)))a array([[ 7., 1., 9., 6.], [ 9., 1., 5., 9.], [ 9., 7., 9., 1.]]) 1a.shape (3, 4) 12# return the array, flattenedprint(a.ravel()) [ 7. 1. 9. 6. 9. 1. 5. 9. 9. 7. 9. 1.] 12# return the array with modified shapeprint(a.reshape(6,2)) [[ 7. 1.] [ 9. 6.] [ 9. 1.] [ 5. 9.] [ 9. 7.] [ 9. 1.]] 12# return the array, transposedprint(a.T) [[ 7. 9. 9.] [ 1. 1. 7.] [ 9. 5. 9.] [ 6. 9. 1.]] 12345# the above three commands all return a modified array, but do not change the original array# the resize function modifies the array itselfprint(a)print(a.resize(2,6))print(a) [[ 7. 1. 9. 6.] [ 9. 1. 5. 9.] [ 9. 7. 9. 1.]] None [[ 7. 1. 9. 6. 9. 1.] [ 5. 9. 9. 7. 9. 1.]] 7.2 Stacking together different arraysvstack() and hstack() 123456a = np.arange(1,5).reshape(2,2)b = np.arange(5,9).reshape(2,2)print(a)print(b)print(np.vstack((a,b)))print(np.hstack((a,b))) [[1 2] [3 4]] [[5 6] [7 8]] [[1 2] [3 4] [5 6] [7 8]] [[1 2 5 6] [3 4 7 8]] 1np.r_[1:4,0,4] array([1, 2, 3, 0, 4]) 1np.c_[1,3,5,7] array([[1, 3, 5, 7]]) 7.3 Splitting one array into several smaller ones12a = np.arange(1,25).reshape(2,12)print(a) [[ 1 2 3 4 5 6 7 8 9 10 11 12] [13 14 15 16 17 18 19 20 21 22 23 24]] 1print(np.hsplit(a,3)) [array([[ 1, 2, 3, 4], [13, 14, 15, 16]]), array([[ 5, 6, 7, 8], [17, 18, 19, 20]]), array([[ 9, 10, 11, 12], [21, 22, 23, 24]])] 123# split the array after the third and the fourth columnprint(np.hsplit(a,(3,4))) [array([[ 1, 2, 3], [13, 14, 15]]), array([[ 4], [16]]), array([[ 5, 6, 7, 8, 9, 10, 11, 12], [17, 18, 19, 20, 21, 22, 23, 24]])] 8. Copies and Views8.1 No Copy at All1234567# Simple assignmentsa = np.arange(12)b = aprint(b is a)b.shape = 3,4print(a.shape) True (3, 4) 8.2 View or Shallow Copy123456# the view method creates a new array object that share the same datac = a.view()print(c is a)print(c.base is a)print(c.flags.owndata) False True False 1234# a's shape doesn't changec.shape = 2,6print(a.shape) (3, 4) 12345# a's data changesprint(c)c[0,4] = 1234print(c)print(a) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] [[ 0 1 2 3 1234 5] [ 6 7 8 9 10 11]] [[ 0 1 2 3] [1234 5 6 7] [ 8 9 10 11]] 12345# slicing an array returns a view of its = a[:,1:3]s[:] = 10print(a) [[ 0 10 10 3] [1234 10 10 7] [ 8 10 10 11]] 8.3 Deep Copy1234567# the copy method makes a complete copy of the array and its datad = a.copy()print(d is a)print(d.base is a)d[0,0] = 9999print(a) False False [[ 0 10 10 3] [1234 10 10 7] [ 8 10 10 11]] 9. Indexing with Boolean Arrays123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltdef mandelbrot(h, w, maxit=20): """ return an image of the Mandelbrot fractal of size (h, w)""" y,x = np.ogrid[-1.4:1.4:h*1j, -2:0.8:w*1j] c = x + y * 1j z = c divtime = maxit + np.zeros(z.shape, dtype = int) for i in range(maxit): z = z**2 + c # who is diverging diverge = z*np.conj(z) &gt; 2**2 # who is diverging now div_now = diverge &amp; (divtime == maxit) # note when divtime[div_now] = i # avoid diverging too much z[diverge] = 2 return divtimeplt.imshow(mandelbrot(400,400))plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引用本地图片]]></title>
    <url>%2F2017%2F05%2F07%2FHexo%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[通过使用hexo-asset-image插件引用本地图片，解决Hexo直接引用本地图片路径混乱的问题 配置将_config.yml中参数post_asset_folder的值配置为true 这个参数使得在建立文件时，自动生成一个与文件同名的文件夹，用于存储资源文件 安装插件在hexo目录下执行npm install hexo-asset-image --save命令安装插件 使用假设在相应的资源文件下存在图片文件为logo.png，使用如下语法引用图片 ![logo](logo.png)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Programming Computer Vision with Python, Chapter 1]]></title>
    <url>%2F2017%2F05%2F07%2FPythonCV-1%2F</url>
    <content type="text"><![CDATA[基本的图像操作和处理 Chapter 1. 基本的图像操作和处理1.1 PIL 库的导入以及图像的显示方法 1from PIL import Image 12pil_im = Image.open('../data/empire.jpg')pil_im.show() 1.1.1 转换图像格式使用save()方法保存时，PIL会根据文件扩展名判断图像的格式 12345import imtoolsfilelist = imtools.get_imlist("../data")for file in filelist: print(file) ../data/fisherman.jpg ../data/Univ3.jpg ../data/sf_view2.jpg ../data/boy_on_hill.jpg ../data/Univ1.jpg ../data/alcatraz1.jpg ../data/sf_view1.jpg ../data/alcatraz2.jpg ../data/sunset_tree.jpg ../data/climbing_2_small.jpg ../data/crans_1_small.jpg ../data/turningtorso1.jpg ../data/empire.jpg ../data/climbing_1_small.jpg ../data/Univ2.jpg ../data/Univ5.jpg ../data/Univ4.jpg ../data/crans_2_small.jpg 1.1.2 创建缩略图使用thumbnail方法创建缩略图，例如 12pil_im.thumbnail((128, 128))pil_im.show() 1.1.3 复制和粘贴图像区域使用crop()方法从图像中裁剪指定区域 1234567891011pil_im = Image.open('../data/empire.jpg')# 创建裁剪区域box = (100, 100, 400, 400)region = pil_im.crop(box)# 旋转region以便于区分region = region.transpose(Image.ROTATE_180)pil_im.paste(region, box)pil_im.show() 1.1.4 调整尺寸和旋转12345out = pil_im.resize((128, 128))out.show()out = pil_im.rotate(45)out.show() 1.2 Matplotlib1.2.1 绘制图像、点和线1234567891011121314151617181920212223from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('../data/empire.jpg'))figure(figsize = (10, 5))# 绘制图像imshow(im)# 点x = [100, 100, 400, 400]y = [200, 500, 200, 500]# 使用红色星状标记绘制点plot(x, y, 'r*')# 绘制连接线plot(x[:2], y[:2])# 添加标题，显示绘制的图像title('Plotting: "empire.jpg"')show() 1.2.2 图像轮廓和直方图1234567891011121314151617181920212223from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('../data/empire.jpg').convert('L'))# 新建图像figure(figsize = (15,5))gray()# 在原点的左上角显示轮廓图像subplot(1,2,1)contour(im, origin = 'image')axis('equal')axis('off')# 直方图subplot(1,2,2)hist(im.flatten(), 128)# 显示图像show() 1.2.3 交互式标注代码如下所示：12345678910111213from PIL import Imagefrom pylab import *im = array(Image.open('../data/empire.jpg'))imshow(im)print 'Please click 3 points'x = ginput(3)print 'you clicked :', xshow() 示例参见1_2_3.py 1.3 NumPyPython科学计算工具包 1.3.1 图像数组表示NumPy数组访问方式与Python类似 12345678from PIL import Imagefrom numpy import *im = array(Image.open('../data/empire.jpg'))print(im.shape, im.dtype)im = array(Image.open('../data/empire.jpg').convert('L'), 'f')print(im.shape, im.dtype) (800, 569, 3) uint8 (800, 569) float32 1.3.2 灰度变换12345678910111213141516171819202122232425262728293031323334from PIL import Imagefrom numpy import *figure(figsize = (17, 10))gray()im = array(Image.open('../data/empire.jpg').convert('L'))subplot(2,4,1)imshow(im)subplot(2,4,5)hist(im.flatten(), 128)# 反相操作im2 = 255 - imsubplot(2,4,2)imshow(im2)subplot(2,4,6)hist(im2.flatten(), 128)# 将图像像素值变换到100-200区间im3 = (100.0/255) * im + 100subplot(2,4,3)imshow(im3)subplot(2,4,7)hist(im3.flatten(), 128)# 对图像像素值求平方后得到的图像im4 = 255.0 * (im/255.0)**2subplot(2,4,4)imshow(im4)subplot(2,4,8)hist(im4.flatten(), 128)show() 1.3.3 图像缩放12345""" 图像缩放 """def imresize(im, sz): pil_im = Image.fromarray(uint8(im)) return array(pil_im.resize(sz)) 1.3.4 直方图均衡化123456789101112131415161718192021import imtoolsfrom PIL import Imagefrom numpy import *im = array(Image.open('../data/AquaTermi_lowcontrast.jpg').convert('L'))im2, cdf = imtools.histeq(im)figure(figsize = (15, 10))gray()subplot(2,2,1)imshow(im)subplot(2,2,3)hist(im.flatten(), 128)subplot(2,2,2)imshow(im2)subplot(2,2,4)hist(im2.flatten(), 128)show() 1.3.5 图像平均12345678910111213141516""" 图像平均 """def compute_average(imlist): # 打开第一幅图像，将其存储在浮点型数组中 averageim = array(Image.open(imlist[0]), 'f') for imname in imlist[1:]: try: averageim += array(Image.open(imname)) except: print(imname + '...skipped') averageim /= len(imlist) # 返回uint8类型的平均图像 return array(averageim, 'uint8') 1.3.6 图像的主成分分析（PCA）12345678910111213141516171819202122232425262728293031323334353637""" 主成分分析： 输入：矩阵X，其中该矩阵中存储训练数据，每一行为一条训练数据 返回：投影矩阵（按照维度的重要性排序）、方差和均值 """def pca(X): # 获取维数 num_data, dim = X.shape # 数据中心化 mean_X = X.mean(axis = 0) X = X - mean_X if dim &gt; num_data: # 使用紧致技巧 # 协方差矩阵 M = dot(X, X.T) # 特征值和特征向量 e, EV = linalg.eigh(M) # 紧致技巧 tmp = dot(X.T, EV).T # 由于最后的特征向量是我们所需要的，所以需要将其逆转 V = tmp[::-1] # 由于特征值是按照递增顺序排列的，所以需要将其逆转 S = sqrt(e)[::-1] for i in range(V.shape[1]): V[:, i] /= S else: # 使用SVD方法 U, S, V = linalg.svd(X) # 仅仅返回前num_data维数据 V = V[:num_data] # 返回投影矩阵、方差和均值 return V, S, mean_X 12345678910111213141516171819202122232425262728293031323334from PIL import Imagefrom numpy import *from pylab import *import pcaimport imtools# 获取图像列表imlist = imtools.get_imlist("../data/a_thumbs")# 打开一幅图像，获取大小im = array(Image.open(imlist[0]))m, n = im.shape[0:2]# 获取图像数目imnbr = len(imlist)# 创建矩阵，保存所有图像数据immatrix = array([array(Image.open(im)).flatten() for im in imlist], 'f')# 主成分分析V, S, immean = pca.pca(immatrix)# 显示结果figure(figsize = (20, 10))gray()subplot(2,4,1)# 显示均值imshow(immean.reshape(m, n))axis('off')# 显示前7个模式for i in range(7): subplot(2, 4, i+2) imshow(V[i].reshape(m,n)) axis('off') show() 1.3.7 保存数据使用pickle模块使用pickle可以封装几乎所有的python对象 封装123with open('font_pca_modes.pkl', 'wb') as f: pickle.dump(immean, f) pickle.dump(V, f) 拆封123with open('font_pca_modes.pkl', 'rb') as f: immean = pickle.load(f) V = pickle.load(f) 使用NumPy的读写函数如果数据结构不复杂，可以直接将其存为文本文件 12savetxt('test.txt', x, '%i')x = loadtxt('test.txt') 1.4 ScipyScipy提供关于图像处理的许多功能模块 1.4.1 图像模糊1234567891011121314151617from PIL import Imagefrom pylab import *from numpy import *from scipy.ndimage import filtersfigure(figsize = (15,10))gray()im = array(Image.open('../data/empire.jpg').convert('L'))sigma = [0, 2, 5, 10]for i in range(4): subplot(1,4,i+1) imshow(filters.gaussian_filter(im, sigma[i])) axis('off')show() 1.4.2 图像导数描述图像强度变化的强弱 1234567891011121314151617181920212223242526272829303132from PIL import Imagefrom pylab import *from numpy import *from scipy.ndimage import filtersfigure(figsize = (15,10))gray()im = array(Image.open('../data/empire.jpg').convert('L'))subplot(1,4,1)imshow(im)axis('off')# Sobel导数滤波器imx = zeros(im.shape)filters.sobel(im, 1, imx)subplot(1,4,2)imshow(imx)axis('off')imy = zeros(im.shape)filters.sobel(im, 0, imy)subplot(1,4,3)imshow(imy)axis('off')magnitude = sqrt(imx**2 + imy**2)subplot(1,4,4)imshow(255-magnitude)axis('off')show() 为了在图像噪声方面更稳健以及在任意尺度上计算导数，我们可以使用高斯导数滤波器 12345678910111213141516171819202122232425262728293031323334from PIL import Imagefrom pylab import *from numpy import *from scipy.ndimage import filtersfigure(figsize = (15,10))gray()im = array(Image.open('../data/empire.jpg').convert('L'))subplot(1,4,1)imshow(im)axis('off')sigma = 10# 高斯导数滤波器imx = zeros(im.shape)filters.gaussian_filter(im, (sigma, sigma), (0, 1), imx)subplot(1,4,2)imshow(imx)axis('off')imy = zeros(im.shape)filters.gaussian_filter(im, (sigma, sigma), (1, 0), imy)subplot(1,4,3)imshow(imy)axis('off')magnitude = sqrt(imx**2)subplot(1,4,4)imshow(255-magnitude)axis('off')show() 1.4.3 形态学：对象计数使用morphology和measurements模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344from PIL import Image# from pylab import *# from numpy import *from scipy.ndimage import measurements, morphology# 读入图片im = array(Image.open('../data/houses.png').convert('L'))# 二值化操作im = 1*(im &lt; 128)figure(figsize = (15, 10))subplot(1,2,1)imshow(im)axis("off")# 形态学计数labels, nbr_obeject = measurements.label(im)subplot(1,2,2)imshow(labels)axis("off")# 显示结果show()print("Before opening operation, Number of objects:", nbr_obeject)# 进行形态学开操作im_open = morphology.binary_opening(im, ones((9, 5)), iterations=2)figure(figsize = (15, 10))subplot(1,2,1)imshow(im_open)axis("off")# 形态学计数labels_open, nbr_obeject_open = measurements.label(im_open)subplot(1,2,2)imshow(labels_open)axis("off")# 显示结果show()print("After opening operation, Number of objects:", nbr_obeject_open) Before opening operation, Number of objects: 45 After opening operation, Number of objects: 48 1.4.4 一些有用的SciPy模块io模块读写.mat文件12345data = scipy.io.loadmat('test.mat')data = &#123;&#125;data['x'] = xscipy.io.savemat('test.mat', data) misc模块将数组对象保存为图像形式1scipy.misc.imsave('test.jpg', im) 1.5 图像去噪图像去噪是在去除图像噪声的同时，尽可能地保留图像细节和结构的处理技术。 这里使用ROF(Rudin-Osher-Fatemi)去噪模型，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from numpy import *""" 实现ROF去噪模型 输入：含有噪声的灰度图像、U的初始值、停止条件、步长、TV正则项权值 输出：去噪和去除纹理后的图像、纹理残留"""def denoise(im, U_init, tolerance=0.1, tau=0.125, tv_weight=100): # 噪声图像的大小 m, n = im.shape # 初始化 U = U_init # 对偶域的x分量 Px = im # 对偶域的y分量 Py = im error = 1 while(error &gt; tolerance): Uold = U # 原始变量的梯度 # 变量U梯度的x分量 GradUx = roll(U, -1, axis=1) - U # 变量U梯度的y分量 GradUy = roll(U, -1, axis=0) - U # 更新对偶变量 PxNew = Px + (tau/tv_weight)*GradUx PyNew = Py + (tau/tv_weight)*GradUy NormNew = maximum(1, sqrt(PxNew**2 + PyNew**2)) # 更新x分量（对偶） Px = PxNew/NormNew # 更新y分量（对偶） Py = PyNew/NormNew # 更新原始变量 # 对x分量进行向右x轴平移 RxPx = roll(Px, 1, axis=1) # 对y分量进行向右y轴平移 RyPy = roll(Py, 1, axis=0) # 对偶域的散度 DivP = (Px-RxPx) + (Py-RyPy) # 更新原始变量 U = im + tv_weight * DivP # 更新误差 error = linalg.norm(U-Uold)/sqrt(m*n) return U, im-U 下面是合成的噪声图像示例 1234567891011121314151617181920212223242526272829from numpy import *from numpy import randomfrom scipy.ndimage import filtersimport rof# 使用噪声创建合成图像im = zeros((500, 500))im[100:400, 100:400] = 128im[200:300, 200:300] = 255im_noise = im + 30*random.standard_normal((500, 500))U, T = rof.denoise(im_noise, im_noise)figure(figsize = (15, 10))gray()subplot(1,3,1)imshow(im)axis('off')subplot(1,3,2)imshow(im_noise)axis('off')subplot(1,3,3)imshow(U)axis('off')show()]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Image Library]]></title>
    <url>%2F2017%2F04%2F25%2FPython-Image-Library%2F</url>
    <content type="text"><![CDATA[Python图像库PIL的安装以及问题 下载在这里下载PIL源代码 安装下载依赖库PIL需要依赖一些图像库，执行以下代码安装依赖库 1234sudo apt-get install libjpeg62-devsudo apt-get install zlib1g-devsudo apt-get install libfreetype6-devsudo apt-get install liblcms1-dev build解压下载文件，并进入目录 执行python setup.py build_ext -i进行build并给出环境报告，如下所示 12345678----------------------------------------------------------------PIL 1.1.7 SETUP SUMMARY----------------------------------------------------------------*** TKINTER support not available (Tcl/Tk 8.5 libraries needed)--- JPEG support available--- ZLIB (PNG/ZIP) support available--- FREETYPE support available---------------------------------------------------------------- 执行python selftest.py进行安装前的测试 如果上述操作没有任何错误，则可以执行python setup.py install进行最后的安装 TroubleShootingdecoder jpeg not available如果出现以上错误，首先确认是否安装了相应的依赖库。 如果确定依赖库安装成功后仍有上述错误，则有可能是PIL无法定位相应的依赖库，此时执行以下代码即可 123sudo ln -s /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/libsudo ln -s /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/libsudo ln -s /usr/lib/x86_64-linux-gnu/libz.so /usr/lib]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Favourite Theme]]></title>
    <url>%2F2017%2F03%2F02%2FMy%20Favourite%20Theme%2F</url>
    <content type="text"><![CDATA[收集的一些比较喜欢的Hexo主题 A [Alex] - A very simple, elegant and responsive for Hexo. - _Demo_ [Apollo] - A clean, minimal and responsive theme, based on the Tumblr theme. - _Demo_ [AWE] - An Awesome UI Kit based theme - _Demo_ C [Coney] - A theme based on Pacman, especially for Chinese! change the display style, add baidu share module, baidu search module, baidu analytics module, up to top button and so on. - _Demo_ D [dream] - A completefull function and pretty ui hexo theme base on Pacman. - _Demo_ I [Iceman] - A simple theme with some built-in China mainland service, based on Pacman - _Demo_ J [Jacman] - A fresh looking and responsive theme for Hexo with more features based on Pacman - _Demo_ K [Kiddochan] - A simple, flexible and responsive theme for Hexo based on Jacman. - _Demo_ N [NexT] - High quality elegant theme. - _Demo_ P [Pln] - A plain theme for Hexo. - _Demo_ Y [Yilia] - Responsive and simple style - _Demo_]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime中文输入]]></title>
    <url>%2F2017%2F03%2F02%2FSublime%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[解决Sublime中无法输入中文的问题 准备工作安装Sublime与搜狗输入法 生成所需文件 将下面代码保存到~目录下的sublime_imfix.c中 1234567891011121314151617#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),"window",window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context);&#125; 将上面的C文件编译成共享库libsublime-imfix.so 1gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC 将libsublime-imfix.so移动到Sublime文件夹中 1sudo mv libsublime-imfix.so /opt/sublime_text/ 修改文件/usr/bin/subl执行 1sudo gedit /usr/bin/subl 将 12#!/bin/shexec /opt/sublime_text/sublime_text "$@" 修改为 12#!/bin/shLD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text "$@" 此时，在命令中执行subl将可以使用搜狗输入法输入中文 修改文件sublime_text.desktop1sudo gedit /usr/share/applications/sublime_text.desktop 将[Desktop Entry]中的字符串 1Exec=/opt/sublime_text/sublime_text %F 修改为 1Exec=bash -c "LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F" 将[Desktop Action Window]中的字符串 1Exec=/opt/sublime_text/sublime_text -n 修改为 1Exec=bash -c "LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n" 将[Desktop Action Document]中的字符串 1Exec=/opt/sublime_text/sublime_text --command new_file 修改为 1Exec=bash -c "LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file"]]></content>
      <categories>
        <category>Sublime</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo建立Blog]]></title>
    <url>%2F2017%2F03%2F02%2F%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%2F</url>
    <content type="text"><![CDATA[Hexo是一款基于Node.js的静态博客框架，用Hexo搭建博客可以自由配置需要的功能、界面，所以闲着没事也自己搭了个。以下所有操作针对Ubuntu系统，当然其他操作系统大体类似。 安装必要工具Node.js首先安装Node.js，在官网下载相对应的版本，安装即可 Hexo命令行下执行npm install -g hexo-cli即可 Hexo用来根据配置文件生成静态页面 Git命令行下执行sudo apt-get install git即可 如果没有GitHub账号的话，还需要申请Github账号，这里Github是用来托管生成的静态页面的 配置建立Github仓库在Github上建立名为”name.github.io”的仓库，固定写法，name自取，这个仓库所存储的静态页面可以通过域名https://name.github.io直接访问 初始化博客123456// 新建文件夹存储相关文件，并初始化hexo init &lt;folder&gt;// 进入文件夹cd &lt;folder&gt;// 安装依赖，这是个node.js命令npm install 配置博客初始化完成后，在建立的博客文件夹下会出现很多文件以及文件夹，其中_config.yml文件就是博客的配置文件，配置文件很长，但是大多数都不需要修改，需要修改的主要是以下几部分： 网站相关信息1234567# Sitetitle: InnoBlogsubtitle: May The Force Be With Youdescription: Innoecho&apos;s Blogauthor: Innoecholanguage: entimezone: Asia/Shanghai 其中language和timezone都有相应的规范，需要查阅相关的规范文件来获得参数值 部署信息12345# Deploymentdeploy: type: git repo: git@github.com:Innoecho/Innoecho.github.io.git branch: master 这里的repo即为前面创建的Github仓库的地址 主题12# Extensionstheme: light 以我正在使用的主题为例，在创建的博客文件夹下执行1git clone git://github.com/tommy351/hexo-theme-light.git themes/light 并修改theme参数为light即可 到这里，Hexo博客框架就搭建完毕 使用博客写博客在博客目录下，执行1hexo new &quot;文章标题&quot; 即在博客目录/source/post文件夹下生成相应的文章标题.md文件 编辑该文件，输入文章内容 本地发布写好博客之后，执行1hexo server server命令将静态文件发布到本地，通过*http://localhost:4000\*访问 部署本地发布检查没问题之后，需要将静态文件部署到Github仓库，才可以让其他人通过互联网访问，执行12hexo generatehexo deploy 其中，generate命令根据md文件以及相应的配置文件生成静态文件，deploy命令将生成的静态文件部署到Github的仓库中 现在，整个博客的发布流程到此结束 TroubleShootingDeployer not found: git执行1npm install hexo-deployer-git --save 然后进行部署 去除代码块的行号在_config.yml文件中的12345highlight: enable: true line_number: false auto_detect: false tab_replace: 博客源文件的保存hexo deploy命令是将生成的静态页面部署到Github仓库，如果想要同时保存源文件，那么可以在Github仓库中新建一个分支来保存，具体操作流程如下： 123456789101112// git初始化，在博客目录下执行git init// 添加仓库地址git remote add origin https://github.com/username/reponame.git// 新建分支并切换到新建的分支git checkout -b source// 添加所有本地文件到gitgit add .// git提交git commit -m &quot;&quot;// 文件推送到source分支git push origin source 在更新博客的源文件之后，除了使用hexo命令将静态页面部署到Github，还需要使用git命令将源文件push到Github仓库 123456// 添加源文件git add .// git提交git commit -m &quot;&quot;// push源文件git push origin source 另外，由于public文件夹由hexo根据source文件夹以及配置文件生成，所以没有必要保存public文件夹。对此，可以在博客目录下建立.gitignore文件，将以下内容添加到文件中123node_modules/public/.deploy*/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号服务接口]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[利用Python建立简单的微信公众号服务接口 在SAE上搭建服务在SAE注册登陆后，创建新的应用，填写二级域名，记下这个地址，选择空的Python应用，因为一直用的Git，所以顺理成章的选了Git 在本地初始化仓库并配置远程仓库git init git remote add sae https://git.sinacloud.com/innoechowechat 代码框架首先是config.yaml 12345678name: InnoechoWechatversion: 1libraries:- name: webpy version: "0.36"... 接下来是index.wsgi 123456789101112131415161718import osimport saeimport websae.add_vendor_dir('vendor')from WechatInterface import WechatInterfaceurls = ('/wechat','WechatInterface')app_root = os.path.dirname(__file__)templates_root = os.path.join(app_root, 'templates')render = web.template.render(templates_root)app = web.application(urls, globals()).wsgifunc() application = sae.create_wsgi_app(app) 然后我们需要创建WechatInterface类来响应请求 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import hashlibimport webimport osclass WechatInterface: def __init__(self): self.app_root = os.path.dirname(__file__) self.templates_root = os.path.join(self.app_root, 'templates') self.render = web.template.render(self.templates_root) def GET(self): #获取输入参数 data = web.input() signature = data.signature timestamp = data.timestamp nonce = data.nonce echostr = data.echostr #微信设置的token token = "000400" #字典序排序 list = [token,timestamp,nonce] list.sort() sha1 = hashlib.sha1() map(sha1.update,list) hashcode = sha1.hexdigest() #sha1加密算法 #如果是来自微信的请求，则回复echostr if hashcode == signature: return echostr 至此代码框架搭建完毕 部署代码按照下面的操作，将代码部署到SAE git add . git commit -m &quot;Test&quot; git push sae master:1 配置微信公众平台在微信公众平台注册登陆后，选择开发选项卡中的基本配置，然后修改服务器配置。 URL = http://innoechowechat.applinzi.com/wechat Token = 000400 这两个需要与SAE上的设置保持一致，URL即服务的地址，即SAE的应用地址+服务地址，Token则相当于密码，随意取即可。 正常提交之后，微信公众号接收到的信息就会被转发到SAE上的服务上面，但是此时这个服务并没有任何作用，仅能通过微信的认证而已 添加echo服务在WechatInterface类中添加POST方法（记得import相关的依赖） 1234567891011def POST(self): #获得post来的数据 str_xml = web.data() #进行XML解析 xml = etree.fromstring(str_xml) #获得用户所输入的内容 content = xml.find("Content").text msgType = xml.find("MsgType").text fromUser = xml.find("FromUserName").text toUser = xml.find("ToUserName").text return self.render.reply_text(fromUser,toUser,int(time.time()),content) 另外还需要在templates目录下创建reply_text.xml模板文件 12345678$def with (toUser,fromUser,createTime,content)&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;$createTime&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt;&lt;/xml&gt; 简单的echo服务搭建完毕～]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>微信</tag>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝牙模块]]></title>
    <url>%2F2017%2F03%2F02%2F%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[UAV上使用的蓝牙模块以及与Pixhawk的连接 针脚定义蓝牙模块为HC-05主从机一体蓝牙模块 6个针脚定义如下： VCC：3.3V GND：地线 RX：接收 TX：发送 STATE：输出针脚，若蓝牙模块处于连接状态则为高电平，否则为低电平 EN：用来控制AT指令模式与正常工作模式的切换，我们所使用的模块包含一个按键，这个按键可以使EN置高或置低，因此可以忽略EN针脚 模式切换有两种进入AT指令模式的方法： 在模块上电前，按住按键使EN置高，然后上电，此时LED灯慢闪（2秒一次），此种方式波特率为38400 正常上电，此时LED灯快闪（1秒两次），之后按一次按键，LED灯不会发生变化，但是此时已进入AT模式，此种方式波特率为9600 常用AT指令 测试指令：AT，返回OK 查询版本号：AT+VERSION?，返回软件版本号 查询模块地址：AT+ADDR?，返回模块地址 查询模块名称：AT+NAME?，返回模块名称，但是这条命令在我使用的模块下无法返回名称 设置模块名称：AT+NAME=，返回OK则设置成功 查询模块配对码：AT+PSWD?，返回模块配对码 设置模块配对码：AT+PSWD=，返回OK则设置成功 查询模块串口参数：AT+UART?，返回模块串口参数（波特率，停止位，校验位） 设置模块串口参数：AT+UART=,,，返回OK则设置成功 与飞控连接设置好蓝牙模块后，将其与飞控板连接，这里我所使用的是Pixhawk，它的TELEM1端口从左至右排序依次为：VCC，RX，TX，空，空，GND 依照上述方式将蓝牙模块与飞控板连接，简单测试Tower可以与Pixhawk正常连接，在此基础上可以开发基于蓝牙的地面站]]></content>
      <categories>
        <category>UAV</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
        <tag>PixHawk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞控固件编译]]></title>
    <url>%2F2017%2F03%2F02%2F%E9%A3%9E%E6%8E%A7%E5%9B%BA%E4%BB%B6%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[关于PX4以及APM飞控固件的编译问题 PX4InstallationTo compile the code, CMake and GCC are necessary. CMakesudo add-apt-repository ppa:george-edison55/cmake-3.x -y sudo apt-get update sudo apt-get install cmake -y GCCsudo add-apt-repository ppa:terry.guo/gcc-arm-embedded -y sudo apt-get update sudo apt-get install gcc-arm-none-eabi -y NuttX based hardwareUbuntu comes with a serial modem manager which interferes heavily with any robotics related use of a serial port (or USB serial). It can deinstalled without side effects: sudo apt-get remove modemmanager Permission SetupBecause the “tty” belong to the group “dialout”, to operate the pixhawk the user needs to be added to the group “dialout”: sudo usermod -a -G dialout $USER And then you have to logout and login again, as this is only changed after a new login. Compiling on the ConsoleWe default to ‘~/src/Firmware’ and clone the upstream repository. mkdir -p ~/src cd ~/src git clone https://github.com/PX4/Firmware.git cd Firmware git submodule update --init --recursive make px4fmu-v2_default Upload to the pixhawkBy appending ‘upload’ to these commands the compiled binary will be uploaded via USB to the pixhawk: make px4fmu-v2_default upload A successful run will end with this output: Erase : [====================] 100.0% Program: [====================] 100.0% Verify : [====================] 100.0% Rebooting. [100%] Built target upload APMIf you have configured the environment for PX4, you can clone the APM code and compile it directly. InstallationThere is a script to config the environment easily， what we need to do is just clone from ardupilot and run this script: git clone https://github.com/diydrones/ardupilot.git ardupilot/Tools/scripts/install-prereqs-ubuntu.sh -y Reload the path (log-out and log-in to make permanent): . ~/.profile Compiling on the ConsoleBuild for Copter cd ardupilot/ArduCopter make px4-v2 Loading firmwareTo load the firmware onto the board use make px4-v1-upload After it says “waiting for bootloader” plugin your Pixhawk on USB.]]></content>
      <categories>
        <category>UAV</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>UAV</tag>
        <tag>Compile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle编译]]></title>
    <url>%2F2017%2F03%2F02%2FGradle%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Android开发工具Gradle的安装以及使用 下载Gradle切换到项目的根目录，执行 ./gradlew -v 查看所使用的Gradle的版本，如果是第一次执行，则会下载所需版本。 下载依赖项执行 ./gradlew clean 下载所需依赖项，这步遇到较多问题： SDK Location not found：执行export ANDROID_HOME=&lt;sdk dir&gt;配置环境变量 failed to find Build Tools revision：修改build.gradle文件 我编译的是DroneKit的例子Hello Drone，这个例子教程中导入的库是‘com.o3dr.android:dronekit-android:2.3.+’，github上的版本导入的库是‘com.o3dr.android:dronekit-android:2.7.+’，然而这两种都会提示无法找到对应的库，在jcenter中最新的库是‘com.o3dr.android:dronekit-android:2.9.0’，导入这个库就不会报错了。 编译APK执行 ./gradlew build 编译生成APK文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio安装]]></title>
    <url>%2F2017%2F03%2F02%2FAndroid%20Studio%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Android Studio的安装方法 下载 Android Studio JDK 屏蔽向导将下载好的Android Studio解压到想要放置的位置，修改/bin/idea.properties，在最末行添加disable.android.first.run=true，这样在初次运行时就可以避开向导。 设置代理运行/bin/studio.sh，直接进入成功安装后的界面，但此时无法新建工程，SDK Manager也无法运行。在setting中的Proxy中设置代理，可用的代理在这里 安装依赖库可能由于我的电脑是64位系统，如果直接安装会出现unable to run mksdcard sdk tool这样的错误，因此，要安装Android Studio还必须安装以下依赖库 sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6 正常安装恢复/bin/idea.properties，再次运行/bin/studio.sh，正常安装即可。 虚拟机安装Android Studio自带的模拟器虽然在不断完善，然而我采用号称最快的Android模拟器——Genymotion 首先安装Virtualbox，这个需要注意版本要在5.0.4以上 安装Genymotion，除了安装以外，还需要注册账号，并申请License 安装Androd Studio插件，如果网络不给力的话，可以在这里下载手动安装 这样就可以在Android Studio中启动Genymotion，第一次运行需要指定安装目录 下载想要的Android机，Enjoy~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2017%2F03%2F02%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[科学上网工具XX-Net的使用 简介GoAgent的续作，具体使用方法参见XX-net 问题 将XX-net作为后台服务运行 将XX-bet.sh路径添加到~/bashrc 启动：sudo ./xx_net.sh start 停止：sudo ./xx_net.sh stop 重启：sudo ./xx_net.sh restart 系统全局代理 在终端执行export http_proxy=http://localhost:8085 如果想始终代理，可在~/bashrc中添加上述命令 部署服务端 使用部署工具部署 cd ~/Source/XX-Net/code/default/gae_proxy/server/ sudo python uploader.py &quot;appid&quot;]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>VPN</tag>
        <tag>XX-Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apt_get Update TroubleShooting]]></title>
    <url>%2F2017%2F03%2F02%2FApt-get-Update-TroubleShooting%2F</url>
    <content type="text"><![CDATA[使用Apt-get的问题合集 公钥W: 以下 ID 的密钥没有可用的公钥：8B48AD6246925553 执行 gpg --keyserver subkeys.pgp.net --recv xxx gpg --export --armor xxx | sudo apt-key add - xxx为密钥后8位 Chrome源无法下载 http://dl.google.com/linux/chrome/deb/dists/stable/Release Unable to find expected entry ‘main/binary-i386/Packages’ in Release file (Wrong sources.list entry or malformed file) cd /etc/apt/sources.list.d sudo gedit google-chrome.list 将旧的源列表修改为deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main 原因：官方的Chrome不再提供32位包 删除源W:无法下载… 解决办法：将对应的PPA删掉 cd /etc/apt/sources.list.d ls sudo mv &lt;***&gt;.list &lt;***&gt;.list.bak]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Apt-get</tag>
      </tags>
  </entry>
</search>